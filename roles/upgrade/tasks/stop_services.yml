---

- name: "Execute CHECKPOINT before stopping PostgreSQL"
  ansible.builtin.command: psql -tAXc "CHECKPOINT"
  async: "{{ pg_start_stop_timeout | int }}"  # run the command asynchronously
  poll: 0
  register: checkpoint_result

- name: Wait for the CHECKPOINT to complete
  ansible.builtin.async_status:
    jid: "{{ checkpoint_result.ansible_job_id }}"
  register: checkpoint_job_result
  until: checkpoint_job_result.finished
  retries: "{{ (pg_start_stop_timeout | int) // 10 }}"
  delay: 10

# Try to wait for the window to appear without lag replication before stopping PostgreSQL
- name: Wait until replication lag is 0 bytes
  ansible.builtin.command: >-
    psql -tAXc "select
      coalesce(max(pg_wal_lsn_diff(pg_current_wal_lsn(),replay_lsn)),1) as pg_lag_bytes
      from pg_stat_replication"
  register: pg_lag_bytes
  until: pg_lag_bytes.stdout|int == 0
  retries: 60  # max duration 2 minutes
  delay: 2
  changed_when: false
  failed_when: false
  when:
    - inventory_hostname in groups['primary']
    - pg_old_version is version('10', '>=')

# for compatibility with Postgres 9.x
- name: Wait until replication lag is 0 bytes
  ansible.builtin.command: >-
    psql -tAXc "select
      coalesce(max(pg_xlog_location_diff(pg_current_xlog_location(),replay_location)),1) as pg_lag_bytes
      from pg_stat_replication"
  register: pg_lag_bytes
  until: pg_lag_bytes.stdout|int == 0
  retries: 60  # max duration 2 minutes
  delay: 2
  changed_when: false
  failed_when: false
  when:
    - inventory_hostname in groups['primary']
    - pg_old_version is version('10', '<')

# Stop, if replication lag is high
- block:
    - name: "Print replication lag"
      ansible.builtin.debug:
        msg: "Current replication lag: {{ pg_lag_bytes.stdout | int | human_readable }}"

    - name: "Replication lag detected"
      ansible.builtin.fail:
        msg: "There's a replication lag in the PostgreSQL Cluster. Please try again later."
  when:
    - pg_lag_bytes.stdout is defined
    - pg_lag_bytes.stdout|int != 0

# Stop PostgreSQL (if replication lag is 0 bytes)
- name: Stop PostgreSQL on the Leader
  ansible.builtin.command: >-
    {{ pg_old_bindir }}/pg_ctl -D {{ pg_old_datadir }} stop -m fast -w -t {{ pg_start_stop_timeout }}
  when:
    - inventory_hostname in groups['primary']

- name: Stop PostgreSQL on the Replica
  ansible.builtin.command: >-
    {{ pg_old_bindir }}/pg_ctl -D {{ pg_old_datadir }} stop -m fast -w -t {{ pg_start_stop_timeout }}
  when:
    - inventory_hostname in groups['secondary']

# additional checks using pg_ctl
- name: "Check if PostgreSQL {{ pg_old_version }} is stopped"
  ansible.builtin.command: "{{ pg_old_bindir }}/pg_ctl status -D {{ pg_old_datadir }}"
  register: pg_ctl_status_old_result
  failed_when: false
  changed_when: false

- name: "Check if PostgreSQL {{ pg_new_version }} is stopped"
  ansible.builtin.command: "{{ pg_new_bindir }}/pg_ctl status -D {{ pg_new_datadir }}"
  register: pg_ctl_status_new_result
  failed_when: false
  changed_when: false

- name: "Stop PostgreSQL {{ pg_old_version }}"
  ansible.builtin.command: >
    {{ pg_old_bindir }}/pg_ctl -D {{ pg_old_datadir }} stop -w -t {{ pg_start_stop_timeout }}
  when:
    - pg_ctl_status_old_result is defined
    - pg_ctl_status_old_result.rc == 0

- name: "Stop PostgreSQL {{ pg_new_version }}"
  ansible.builtin.command: >
    {{ pg_new_bindir }}/pg_ctl -D {{ pg_new_datadir }} stop -w -t {{ pg_start_stop_timeout }}
  when:
    - pg_ctl_status_new_result is defined
    - pg_ctl_status_new_result.rc == 0

...
