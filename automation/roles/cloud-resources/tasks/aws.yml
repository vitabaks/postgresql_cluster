---
# Dependencies
- name: Install Python dependencies
  block:
    - name: Ensure that 'python3-pip' package is present on controlling host
      ansible.builtin.command: which pip3
      register: pip3_check
      failed_when: false
      changed_when: false

    - name: Clean dnf cache
      ansible.builtin.command: dnf clean all
      when:
        - pip3_check.rc != 0
        - ansible_os_family == "RedHat"

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600
      register: apt_status
      until: apt_status is success
      delay: 5
      retries: 3
      when:
        - pip3_check.rc != 0
        - ansible_os_family == "Debian"

    - name: Install 'python3-pip' package on controlling host
      ansible.builtin.package:
        name: python3-pip
        state: present
      register: package_status
      until: package_status is success
      delay: 10
      retries: 3
      when:
        - pip3_check.rc != 0
        - ansible_distribution != "MacOSX"

    - name: Ensure that 'boto3' dependency is present on controlling host
      ansible.builtin.pip:
        name: boto3
        executable: pip3
        extra_args: --user
      become: false
      vars:
        ansible_become: false
      environment:
        PATH: "{{ ansible_env.PATH }}:/usr/local/bin:/usr/bin"
        PIP_BREAK_SYSTEM_PACKAGES: "1"
  delegate_to: 127.0.0.1
  run_once: true

# SSH key
- block:
    # Delete the temporary ssh key from the cloud (if exists)
    - name: "AWS: Remove temporary SSH key '{{ ssh_key_name }}' from cloud (if any)"
      amazon.aws.ec2_key:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ ssh_key_name }}"
        region: "{{ server_location }}"
        state: absent
      when:
        - ssh_key_name is defined
        - tmp_ssh_key_name is defined
        - ssh_key_name == tmp_ssh_key_name

    # if ssh_key_name and ssh_key_content is specified, add this ssh key to the cloud
    - name: "AWS: Add SSH key '{{ ssh_key_name }}' to cloud"
      amazon.aws.ec2_key:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ ssh_key_name }}"
        key_material: "{{ ssh_key_content }}"
        region: "{{ server_location }}"
        state: present
      register: ssh_key_result
      when:
        - ssh_key_name | length > 0
        - ssh_key_content | length > 0
  when: state == 'present'

# Create (if state is present)
- block:
    # if server_network is specified, get vpc id for this subnet
    - block:
        - name: "AWS: Gather information about VPC subnet for '{{ server_network }}'"
          amazon.aws.ec2_vpc_subnet_info:
            region: "{{ server_location }}"
            subnet_ids: "{{ server_network }}"
          register: vpc_subnet_info

        - name: "Set variable: vpc_id"
          ansible.builtin.set_fact:
            vpc_id: "{{ vpc_subnet_info.subnets[0].vpc_id }}"
          when: vpc_subnet_info.subnets[0].vpc_id is defined
      when: server_network | length > 0

    # if server_network is not specified, use default vpc subnet
    - block:
        - name: "AWS: Gather information about default VPC"
          amazon.aws.ec2_vpc_net_info:
            region: "{{ server_location }}"
            filters:
              "is-default": true
          register: vpc_info

        # if no default vpc
        - name: "No default VPC found"
          ansible.builtin.debug:
            msg: "No default VPC found in region {{ server_location }}"
          when: vpc_info.vpcs | length == 0 or vpc_info.vpcs[0].id is not defined

        - name: "AWS: Gather information about VPC subnet for default VPC"
          amazon.aws.ec2_vpc_subnet_info:
            region: "{{ server_location }}"
            filters:
              vpc-id: "{{ vpc_info.vpcs[0].id }}"
          register: vpc_subnet_info
          when: vpc_info.vpcs[0].id is defined

        - name: "Set variable: vpc_id"
          ansible.builtin.set_fact:
            vpc_id: "{{ vpc_info.vpcs[0].id }}"
          when: vpc_info.vpcs[0].id is defined

        - name: "Set variable: server_network"
          ansible.builtin.set_fact:
            server_network: "{{ vpc_subnet_info.subnets[0].id }}"
          when: vpc_subnet_info.subnets[0].id is defined
      when: server_network | length < 1

    # if server_network is not specified and there is no default VPC, create a VPC, subnet, gateway and route table
    - block:
        - name: "AWS: Create VPC"
          amazon.aws.ec2_vpc_net:
            name: "{{ aws_vpc_name | default('postgres-cluster-vpc') }}"
            cidr_block: "{{ aws_vpc_cidr | default('10.0.0.0/16') }}"
            region: "{{ server_location }}"
            state: present
          register: aws_vpc

        - name: "AWS: Create subnet"
          amazon.aws.ec2_vpc_subnet:
            vpc_id: "{{ aws_vpc.vpc.id }}"
            cidr: "{{ aws_subnet_cidr | default('10.0.1.0/24') }}"
            region: "{{ server_location }}"
            state: present
          register: aws_subnet

        - name: "AWS: Gather information about VPC subnet for {{ aws_vpc_name | default('postgres-cluster-vpc') }}"
          amazon.aws.ec2_vpc_subnet_info:
            region: "{{ server_location }}"
            filters:
              vpc-id: "{{ aws_vpc.vpc.id }}"
          register: vpc_subnet_info

        - name: "AWS: Create Internet gateway"
          amazon.aws.ec2_vpc_igw:
            vpc_id: "{{ aws_vpc.vpc.id }}"
            state: present
            region: "{{ server_location }}"
          register: aws_igw

        - name: "AWS: Gather information about VPC route tables"
          amazon.aws.ec2_vpc_route_table_info:
            region: "{{ server_location }}"
            filters:
              vpc-id: "{{ aws_vpc.vpc.id }}"
          register: aws_route_table_info

        - name: "AWS: Update the main route table"
          amazon.aws.ec2_vpc_route_table:
            vpc_id: "{{ aws_vpc.vpc.id }}"
            route_table_id: "{{ aws_route_table_info.route_tables[0].route_table_id }}"
            routes:
              - dest: 0.0.0.0/0
                gateway_id: "{{ aws_igw.gateway_id }}"
            region: "{{ server_location }}"

        - name: "Set variable: vpc_id"
          ansible.builtin.set_fact:
            vpc_id: "{{ aws_vpc.vpc.id }}"

        - name: "Set variable: server_network"
          ansible.builtin.set_fact:
            server_network: "{{ aws_subnet.subnet.id }}"
      when: server_network | length < 1

    # Security Group (Firewall)
    - name: "AWS: Create or modify Security Group"
      amazon.aws.ec2_security_group:
        name: "{{ patroni_cluster_name }}-security-group"
        state: present
        description: "Security Group for Postgres cluster"
        vpc_id: "{{ vpc_id }}"
        region: "{{ server_location }}"
        rules: "{{ rules }}"
      vars:
        rules: >-
          {{
            ([
              {
                'rule_desc': 'SSH public access',
                'proto': 'tcp',
                'ports': [ansible_ssh_port | default(22)],
                'cidr_ip': ssh_public_allowed_ips | default('0.0.0.0/0', true) | split(',')
              }
            ] if ssh_public_access | bool else []) +
            ([
              {
                'rule_desc': 'Netdata public access',
                'proto': 'tcp',
                'ports': [netdata_port | default('19999')],
                'cidr_ip': netdata_public_allowed_ips | default('0.0.0.0/0', true) | split(',')
              }
            ] if netdata_install | bool and netdata_public_access | bool else []) +
            ([
              {
                'rule_desc': 'Database public access',
                'proto': 'tcp',
                'ports':
                  ([
                    haproxy_listen_port.master | default('5000'),
                    haproxy_listen_port.replicas | default('5001'),
                    haproxy_listen_port.replicas_sync | default('5002'),
                    haproxy_listen_port.replicas_async | default('5003')
                  ] if with_haproxy_load_balancing | bool else []) +
                  ([
                    pgbouncer_listen_port | default('6432')
                  ] if not with_haproxy_load_balancing | bool and pgbouncer_install | bool else []) +
                  ([
                    postgresql_port | default('5432')
                  ] if not with_haproxy_load_balancing | bool and not pgbouncer_install | bool else []),
                'cidr_ip': database_public_allowed_ips | default('0.0.0.0/0', true) | split(',')
              }
            ] if database_public_access | bool else []) +
            [{
              'rule_desc': 'Postgres cluster ports',
              'proto': 'tcp',
              'ports':
                [ansible_ssh_port | default(22)] +
                ([
                  netdata_port | default('19999')
                ] if netdata_install | bool else []) +
                ([
                  pgbouncer_listen_port | default('6432')
                ] if pgbouncer_install | bool else []) +
                [
                  postgresql_port | default('5432'),
                  patroni_restapi_port | default('8008')
                ] +
                ([
                  haproxy_listen_port.master | default('5000'),
                  haproxy_listen_port.replicas | default('5001'),
                  haproxy_listen_port.replicas_sync | default('5002'),
                  haproxy_listen_port.replicas_async | default('5003'),
                  haproxy_listen_port.stats | default('7000')
                ] if with_haproxy_load_balancing | bool else []) +
                ([
                  etcd_client_port | default('2379'),
                  etcd_peer_port | default('2380')
                ] if dcs_type == 'etcd' else []) +
                ([
                  consul_ports_dns | default('8600'),
                  consul_ports_http | default('8500'),
                  consul_ports_rpc | default('8400'),
                  consul_ports_serf_lan | default('8301'),
                  consul_ports_serf_wan | default('8302'),
                  consul_ports_server | default('8300')
                ] if dcs_type == 'consul' else []),
              'cidr_ip': vpc_subnet_info.subnets[0].cidr_block
            }]
          }}
      register: ec2_security_group_result
      when: cloud_firewall | bool

    # Server and volume
    - name: "AWS: Create or modify EC2 instance"
      amazon.aws.ec2_instance:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
        state: present
        instance_type: "{{ server_type }}"
        image_id: "{{ server_image }}"
        key_name: "{{ ssh_key_name }}"
        region: "{{ server_location }}"
        security_groups: "{{ ([] if not cloud_firewall | bool else [patroni_cluster_name + '-security-group']) }}"
        vpc_subnet_id: "{{ server_network }}"
        network_interfaces:
          - assign_public_ip: true
            delete_on_termination: true
        volumes:
          - device_name: /dev/sda1
            ebs:
              volume_type: "{{ system_volume_type | default('gp3', true) }}"
              volume_size: "{{ system_volume_size | default(80) | int }}"
              delete_on_termination: true
          - device_name: /dev/sdb
            ebs:
              volume_type: "{{ volume_type | default('gp3', true) }}"
              volume_size: "{{ volume_size | int }}"
              delete_on_termination: true
      loop: "{{ range(0, server_count | int) | list }}"
      loop_control:
        index_var: idx
        label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
      register: server_result
      until:
        - server_result.instances[0].public_ip_address is defined
        - server_result.instances[0].public_ip_address | length > 0
      retries: 3
      delay: 10
      when: not server_spot | default(aws_ec2_spot_instance | default(false)) | bool

    # Spot instance (if 'server_spot' is 'true')
    - block:
        - name: "AWS: Gather information about EC2 Spot instances"
          amazon.aws.ec2_instance_info:
            access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
            secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
            region: "{{ server_location }}"
            filters:
              instance-lifecycle: "spot"
              instance-type: "{{ server_type }}"
              image-id: "{{ server_image }}"
              instance-state-name: ["pending", "running", "shutting-down", "stopping", "stopped"]
              "tag:Name": "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
          loop: "{{ range(0, server_count | int) | list }}"
          loop_control:
            index_var: idx
            label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
          register: ec2_spot_instance_info

        # if spot instances are still created, create them
        - name: "AWS: Create a request for EC2 Spot instance"
          amazon.aws.ec2_spot_instance:
            access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
            secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
            region: "{{ server_location }}"
            state: present
            launch_specification:
              instance_type: "{{ server_type }}"
              image_id: "{{ server_image }}"
              key_name: "{{ ssh_key_name }}"
              network_interfaces:
                - subnet_id: "{{ server_network }}"
                  groups: "{{ ec2_security_group_result.group_id }}"
                  associate_public_ip_address: true
                  delete_on_termination: true
                  device_index: 0
              block_device_mappings:
                - device_name: /dev/sda1
                  ebs:
                    volume_type: "{{ volume_type | default('gp3', true) }}"
                    volume_size: 100 # TODO: use 'system_volume_size' variable (https://github.com/ansible-collections/amazon.aws/issues/1949)
                    delete_on_termination: true
                - device_name: /dev/sdb
                  ebs:
                    volume_type: "{{ volume_type | default('gp3', true) }}"
                    volume_size: 100 # TODO: use 'volume_size' variable (https://github.com/ansible-collections/amazon.aws/issues/1949)
                    delete_on_termination: true
            tags:
              Name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
          loop: "{{ ec2_spot_instance_info.results }}"
          loop_control:
            index_var: idx
            label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
          register: ec2_spot_request_result
          when: item.instances[0] | default('') | length < 1

        - name: "AWS: Rename the EC2 Spot instance"
          amazon.aws.ec2_instance:
            access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
            secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
            region: "{{ server_location }}"
            name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
            filters:
              spot-instance-request-id: "{{ item.spot_request.spot_instance_request_id }}"
          loop: "{{ ec2_spot_request_result.results }}"
          loop_control:
            index_var: idx
            label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
          register: ec2_spot_instance_result
          until:
            - ec2_spot_instance_result.instances[0].public_ip_address is defined
            - ec2_spot_instance_result.instances[0].public_ip_address | length > 0
          retries: 3
          delay: 10
          when: item.spot_request.spot_instance_request_id is defined

        # if spot instances are created now
        - name: "Set variable: server_result"
          ansible.builtin.set_fact:
            server_result: "{{ ec2_spot_instance_result }}"
          when: ec2_spot_instance_result.changed | default(false)

        # if spot instances have already been created
        - name: "Set variable: server_result"
          ansible.builtin.set_fact:
            server_result: "{{ ec2_spot_instance_info }}"
          when: not ec2_spot_instance_result.changed | default(false)
      when: server_spot | default(aws_ec2_spot_instance | default(false)) | bool

    # Load Balancer (ELB)
    - name: "AWS: Create or modify Elastic Load Balancer (ELB)"
      amazon.aws.elb_classic_lb:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ patroni_cluster_name }}-{{ item }}"
        region: "{{ server_location }}"
        security_group_ids:
          - "{{ ec2_security_group_result.group_id }}"
        subnets:
          - "{{ server_network }}"
        instance_ids: "{{ server_result.results | map(attribute='instances') | map('first') | map(attribute='instance_id') }}"
        purge_instance_ids: true
        listeners:
          - protocol: tcp
            load_balancer_port: "{{ pgbouncer_listen_port | default('6432') if pgbouncer_install | bool else postgresql_port | default('5432') }}"
            instance_port: "{{ pgbouncer_listen_port | default('6432') if pgbouncer_install | bool else postgresql_port | default('5432') }}"
        health_check:
          ping_protocol: "http"
          ping_port: "{{ patroni_restapi_port }}"
          ping_path: "/{{ item }}"
          interval: 5
          timeout: 2
          unhealthy_threshold: 2
          healthy_threshold: 3
        idle_timeout: 600
        scheme: "{{ 'internet-facing' if database_public_access | bool else 'internal' }}"
        state: present
      loop:
        - "primary"
        - "replica"
        - "sync"
      loop_control:
        label: "{{ patroni_cluster_name }}-{{ item }}"
      register: aws_elb_classic_lb
      when: cloud_load_balancer | bool and
            (item == 'primary' or
            (item == 'replica' and server_count | int > 1) or
            (item in ['sync', 'async'] and server_count | int > 1 and synchronous_mode | bool))

    # S3 bucket (Backups)
    - name: "AWS: Create S3 bucket '{{ aws_s3_bucket_name }}'"
      amazon.aws.s3_bucket:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ aws_s3_bucket_name }}"
        region: "{{ aws_s3_bucket_region }}"
        object_lock_enabled: "{{ aws_s3_bucket_object_lock_enabled }}"
        encryption: "{{ aws_s3_bucket_encryption }}"
        public_access:
          block_public_acls: "{{ aws_s3_bucket_block_public_acls }}"
          ignore_public_acls: "{{ aws_s3_bucket_ignore_public_acls }}"
        state: present
      when:
        - (pgbackrest_install | bool or wal_g_install | bool)
        - aws_s3_bucket_create | bool
  when: state == 'present'

- name: Wait for host to be available via SSH
  ansible.builtin.wait_for:
    host: "{{ item.instances[0].public_ip_address }}"
    port: 22
    delay: 5
    timeout: 300
  loop: "{{ server_result.results }}"
  loop_control:
    label: "{{ item.instances[0].public_ip_address | default('N/A') }}"
  when:
    - server_result.results is defined
    - item.instances is defined

# Info
- name: Server info
  ansible.builtin.debug:
    msg:
      id: "{{ item.instances[0].instance_id }}"
      name: "{{ item.instances[0].tags.Name }}"
      image: "{{ item.instances[0].image_id }}"
      type: "{{ item.instances[0].instance_type }}"
      volume_size: "{{ volume_size }} GB"
      public_ip: "{{ item.instances[0].public_ip_address }}"
      private_ip: "{{ item.instances[0].private_ip_address }}"
  loop: "{{ server_result.results }}"
  loop_control:
    label: "{{ item.instances[0].public_ip_address | default('N/A') }}"
  when:
    - server_result.results is defined
    - item.instances is defined

# Inventory
- block:
    - name: "Inventory | Initialize ip_addresses variable"
      ansible.builtin.set_fact:
        ip_addresses: []

    - name: "Inventory | Extract IP addresses"
      ansible.builtin.set_fact:
        ip_addresses: >-
          {{ ip_addresses +
            [{'public_ip': item.instances[0].public_ip_address,
              'private_ip': item.instances[0].private_ip_address}]
          }}
      loop: "{{ server_result.results | selectattr('instances', 'defined') }}"
      loop_control:
        label: "public_ip: {{ item.instances[0].public_ip_address }}, private_ip: {{ item.instances[0].private_ip_address }}"

    - name: "Inventory | Generate in-memory inventory"
      ansible.builtin.import_tasks: inventory.yml
  when:
    - server_result.results is defined
    - server_result.results | selectattr('instances', 'defined')

# Delete the temporary ssh key from the cloud after creating the EC2 instance
- name: "AWS: Remove temporary SSH key '{{ ssh_key_name }}' from cloud"
  amazon.aws.ec2_key:
    access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
    secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
    name: "{{ ssh_key_name }}"
    region: "{{ server_location }}"
    state: absent
  register: ssh_key_result
  when:
    - ssh_key_name is defined
    - tmp_ssh_key_name is defined
    - ssh_key_name == tmp_ssh_key_name

# Delete (if state is absent)
- block:
    - name: "AWS: Delete EC2 instance"
      amazon.aws.ec2_instance:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"
        region: "{{ server_location }}"
        state: absent
      loop: "{{ range(0, server_count | int) | list }}"
      loop_control:
        index_var: idx
        label: "{{ server_name | lower }}{{ '%02d' % (idx + 1) }}"

    - name: "AWS: Delete Elastic Load Balancer (ELB)"
      amazon.aws.elb_classic_lb:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ patroni_cluster_name }}-{{ item }}"
        region: "{{ server_location }}"
        state: absent
      loop:
        - "primary"
        - "replica"
        - "sync"
      loop_control:
        label: "{{ patroni_cluster_name }}-{{ item }}"
      when: item == 'primary' or
            (item == 'replica' and server_count | int > 1) or
            (item in ['sync', 'async'] and server_count | int > 1 and synchronous_mode | bool)

    - name: "AWS: Delete Security Group"
      amazon.aws.ec2_security_group:
        name: "{{ patroni_cluster_name }}-security-group"
        region: "{{ server_location }}"
        state: absent
      register: ec2_security_group_delete
      until: ec2_security_group_delete is success
      delay: 10
      retries: 3

    - name: "AWS: Delete S3 bucket '{{ aws_s3_bucket_name }}'"
      amazon.aws.s3_bucket:
        access_key: "{{ lookup('ansible.builtin.env', 'AWS_ACCESS_KEY_ID') }}"
        secret_key: "{{ lookup('ansible.builtin.env', 'AWS_SECRET_ACCESS_KEY') }}"
        name: "{{ aws_s3_bucket_name }}"
        region: "{{ aws_s3_bucket_region }}"
        state: absent
        force: true
      when:
        - (pgbackrest_install | bool or wal_g_install | bool)
        - aws_s3_bucket_absent | default(false) | bool
  when: state == 'absent'

...
